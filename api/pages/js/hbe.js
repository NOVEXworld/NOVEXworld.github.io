{"title":"","type":"page","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"(() => { 'use strict'; const cryptoObj = window.crypto || window.msCrypto; const storage = window.localStorage; const storageName = 'hexo-bl...","date":"2025-05-14T14:11:41.579Z","updated":"2025-05-14T14:11:41.579Z","comments":true,"path":"api/pages/js/hbe.js","covers":null,"content":"(() => {\n  'use strict';\n\n  const cryptoObj = window.crypto || window.msCrypto;\n  const storage = window.localStorage;\n\n  const storageName = 'hexo-blog-encrypt:#' + window.location.pathname;\n  const keySalt = textToArray('hexo-blog-encrypt的作者们都是大帅比!');\n  const ivSalt = textToArray('hexo-blog-encrypt是地表最强Hexo加密插件!');\n\n// As we can't detect the wrong password with AES-CBC,\n// so adding an empty div and check it when decrption.\nconst knownPrefix = \"<hbe-prefix></hbe-prefix>\";\n\n  const mainElement = document.getElementById('hexo-blog-encrypt');\n  const wrongPassMessage = mainElement.dataset['wpm'];\n  const wrongHashMessage = mainElement.dataset['whm'];\n  const dataElement = mainElement.getElementsByTagName('script')['hbeData'];\n  const encryptedData = dataElement.innerText;\n  const HmacDigist = dataElement.dataset['hmacdigest'];\n\n  function hexToArray(s) {\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map((h => {\n      return parseInt(h, 16);\n    })));\n  }\n\n  function textToArray(s) {\n    var i = s.length;\n    var n = 0;\n    var ba = new Array()\n\n    for (var j = 0; j < i;) {\n      var c = s.codePointAt(j);\n      if (c < 128) {\n        ba[n++] = c;\n        j++;\n      } else if ((c > 127) && (c < 2048)) {\n        ba[n++] = (c >> 6) | 192;\n        ba[n++] = (c & 63) | 128;\n        j++;\n      } else if ((c > 2047) && (c < 65536)) {\n        ba[n++] = (c >> 12) | 224;\n        ba[n++] = ((c >> 6) & 63) | 128;\n        ba[n++] = (c & 63) | 128;\n        j++;\n      } else {\n        ba[n++] = (c >> 18) | 240;\n        ba[n++] = ((c >> 12) & 63) | 128;\n        ba[n++] = ((c >> 6) & 63) | 128;\n        ba[n++] = (c & 63) | 128;\n        j += 2;\n      }\n    }\n    return new Uint8Array(ba);\n  }\n\n  function arrayBufferToHex(arrayBuffer) {\n    if (typeof arrayBuffer !== 'object' || arrayBuffer === null || typeof arrayBuffer.byteLength !== 'number') {\n      throw new TypeError('Expected input to be an ArrayBuffer')\n    }\n\n    var view = new Uint8Array(arrayBuffer)\n    var result = ''\n    var value\n\n    for (var i = 0; i < view.length; i++) {\n      value = view[i].toString(16)\n      result += (value.length === 1 ? '0' + value : value)\n    }\n\n    return result\n  }\n\n  async function getExecutableScript(oldElem) {\n    let out = document.createElement('script');\n    const attList = ['type', 'text', 'src', 'crossorigin', 'defer', 'referrerpolicy'];\n    attList.forEach((att) => {\n      if (oldElem[att])\n        out[att] = oldElem[att];\n    })\n\n    return out;\n  }\n\n  async function convertHTMLToElement(content) {\n    let out = document.createElement('div');\n    out.innerHTML = content;\n    out.querySelectorAll('script').forEach(async (elem) => {\n      elem.replaceWith(await getExecutableScript(elem));\n    });\n\n    return out;\n  }\n\n  function getKeyMaterial(password) {\n    let encoder = new TextEncoder();\n    return cryptoObj.subtle.importKey(\n      'raw',\n      encoder.encode(password),\n      {\n        'name': 'PBKDF2',\n      },\n      false,\n      [\n        'deriveKey',\n        'deriveBits',\n      ]\n    );\n  }\n\n  function getHmacKey(keyMaterial) {\n    return cryptoObj.subtle.deriveKey({\n      'name': 'PBKDF2',\n      'hash': 'SHA-256',\n      'salt': keySalt.buffer,\n      'iterations': 1024\n    }, keyMaterial, {\n      'name': 'HMAC',\n      'hash': 'SHA-256',\n      'length': 256,\n    }, true, [\n      'verify',\n    ]);\n  }\n\n  function getDecryptKey(keyMaterial) {\n    return cryptoObj.subtle.deriveKey({\n      'name': 'PBKDF2',\n      'hash': 'SHA-256',\n      'salt': keySalt.buffer,\n      'iterations': 1024,\n    }, keyMaterial, {\n      'name': 'AES-CBC',\n      'length': 256,\n    }, true, [\n      'decrypt',\n    ]);\n  }\n\n  function getIv(keyMaterial) {\n    return cryptoObj.subtle.deriveBits({\n      'name': 'PBKDF2',\n      'hash': 'SHA-256',\n      'salt': ivSalt.buffer,\n      'iterations': 512,\n    }, keyMaterial, 16 * 8);\n  }\n\n  async function verifyContent(key, content) {\n    const encoder = new TextEncoder();\n    const encoded = encoder.encode(content);\n\n    let signature = hexToArray(HmacDigist);\n\n    const result = await cryptoObj.subtle.verify({\n      'name': 'HMAC',\n      'hash': 'SHA-256',\n    }, key, signature, encoded);\n    console.log(`Verification result: ${result}`);\n    if (!result) {\n      alert(wrongHashMessage);\n      console.log(`${wrongHashMessage}, got `, signature, ` but proved wrong.`);\n    }\n    return result;\n  }\n\n  async function decrypt(decryptKey, iv, hmacKey) {\n    let typedArray = hexToArray(encryptedData);\n\n    const result = await cryptoObj.subtle.decrypt({\n      'name': 'AES-CBC',\n      'iv': iv,\n    }, decryptKey, typedArray.buffer).then(async (result) => {\n      const decoder = new TextDecoder();\n      const decoded = decoder.decode(result);\n\n      // check the prefix, if not then we can sure here is wrong password.\n      if (!decoded.startsWith(knownPrefix)) {\n        throw \"Decode successfully but not start with KnownPrefix.\";\n      }\n\n      const hideButton = document.createElement('button');\n      hideButton.textContent = 'Encrypt again';\n      hideButton.type = 'button';\n      hideButton.classList.add(\"hbe-button\");\n      hideButton.addEventListener('click', () => {\n        window.localStorage.removeItem(storageName);\n        window.location.reload();\n      });\n\n      document.getElementById('hexo-blog-encrypt').style.display = 'inline';\n      document.getElementById('hexo-blog-encrypt').innerHTML = '';\n      document.getElementById('hexo-blog-encrypt').appendChild(await convertHTMLToElement(decoded));\n      document.getElementById('hexo-blog-encrypt').appendChild(hideButton);\n\n      // support html5 lazyload functionality.\n      document.querySelectorAll('img').forEach((elem) => {\n        if (elem.getAttribute(\"data-src\") && !elem.src) {\n          elem.src = elem.getAttribute('data-src');\n        }\n      });\n\n      // support theme-next refresh\n      window.NexT && NexT.boot && typeof NexT.boot.refresh === 'function' && NexT.boot.refresh();\n\n      // TOC part\n      var tocDiv = document.getElementById(\"toc-div\");\n      if (tocDiv) {\n        tocDiv.style.display = 'inline';\n      }\n\n      var tocDivs = document.getElementsByClassName('toc-div-class');\n      if (tocDivs && tocDivs.length > 0) {\n        for (var idx = 0; idx < tocDivs.length; idx++) {\n          tocDivs[idx].style.display = 'inline';\n        }\n      }\n      \n      // trigger event\n      var event = new Event('hexo-blog-decrypt');\n      window.dispatchEvent(event);\n\n      return await verifyContent(hmacKey, decoded);\n    }).catch((e) => {\n      alert(wrongPassMessage);\n      console.log(e);\n      return false;\n    });\n\n    return result;\n\n  }\n\n  function hbeLoader() {\n\n    const oldStorageData = JSON.parse(storage.getItem(storageName));\n\n    if (oldStorageData) {\n      console.log(`Password got from localStorage(${storageName}): `, oldStorageData);\n\n      const sIv = hexToArray(oldStorageData.iv).buffer;\n      const sDk = oldStorageData.dk;\n      const sHmk = oldStorageData.hmk;\n\n      cryptoObj.subtle.importKey('jwk', sDk, {\n        'name': 'AES-CBC',\n        'length': 256,\n      }, true, [\n        'decrypt',\n      ]).then((dkCK) => {\n        cryptoObj.subtle.importKey('jwk', sHmk, {\n          'name': 'HMAC',\n          'hash': 'SHA-256',\n          'length': 256,\n        }, true, [\n          'verify',\n        ]).then((hmkCK) => {\n          decrypt(dkCK, sIv, hmkCK).then((result) => {\n            if (!result) {\n              storage.removeItem(storageName);\n            }\n          });\n        });\n      });\n    }\n\n    mainElement.addEventListener('keydown', async (event) => {\n      if (event.isComposing || event.keyCode === 13) {\n        const password = document.getElementById('hbePass').value;\n        const keyMaterial = await getKeyMaterial(password);\n        const hmacKey = await getHmacKey(keyMaterial);\n        const decryptKey = await getDecryptKey(keyMaterial);\n        const iv = await getIv(keyMaterial);\n\n        decrypt(decryptKey, iv, hmacKey).then((result) => {\n          console.log(`Decrypt result: ${result}`);\n          if (result) {\n            cryptoObj.subtle.exportKey('jwk', decryptKey).then((dk) => {\n              cryptoObj.subtle.exportKey('jwk', hmacKey).then((hmk) => {\n                const newStorageData = {\n                  'dk': dk,\n                  'iv': arrayBufferToHex(iv),\n                  'hmk': hmk,\n                };\n                storage.setItem(storageName, JSON.stringify(newStorageData));\n              });\n            });\n          }\n        });\n      }\n    });\n  }\n\n  hbeLoader();\n\n})();\n","count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"toc":"","data":[]}